---
title: "test-ig"
output: 
    html_document:
        toc: true
---


```{r, message = FALSE, warning = FALSE}
library(testthat)
library(tidyverse)
library(igcop)
cpar <- list(
    c(2.5, 12.3), # nearly independent
    c(2.5, 4.3), # weak dependence spear=.040
    c(2.5, 2.3), # spear=.145
    c(2.5, 0.3), # spear=.244##
    c(2.5, 0.1), # unreliable (for small k)###
    c(5.5,3.1),  # spear=.231
    c(8.5,3.1),  # spear=.330
    c(15.5,3.1), # spear=.462
    c(25.5,3.1), # spear=.553
    c(45.5,3.1), # spear=.629
    c(75.5,3.1), # spear=.674
    c(75.5,7.1), # spear=.661
    c(155.5,3.1), # spear=.714
    c(300.5,3.1), # spear=.733
    c(600.5,3.1), # spear=.743
    c(600.5,7.1), # spear=.829
    c(600.5,14.1), # spear=.853
    c(600.5,34.1), # spear=.811
    c(1200.5,14.1), # spear=.883
    c(2400.5,14.1), # spear=.899
    c(2400.5,34.1), # spear=.918
    c(2400.5,54.1), # spear=.??? unstable for rhoS
    c(2400.5,44.1), # spear=.914
    c(4800.5,34.1), # spear=.937
    c(9600.5,34.1) # spear=.947  # try inference with this parameter vector
)
alpha <- unique(map_dbl(cpar, 2))
theta <- unique(map_dbl(cpar, 1))
tau <- c(10^(-(5:1)), 2:8/10, 1 - 10^(-(1:5)))
set.seed(5)
u <- sample(tau)
v <- sample(tau)
```

# Inverses

### `igl_gen` and `igl_gen_inv`

```{r}
tau2 <- list()
for (i in seq_along(alpha)){
    alpha_ <- alpha[i]
    tau2[[i]] <- igl_gen(igl_gen_inv(tau, alpha_), alpha_)
}
tibble(alpha = alpha,
       tau_original = list(tau),
       tau_through_inverse = tau2) %>% 
    unnest(everything()) %>% 
    mutate(diff = abs(tau_original - tau_through_inverse)) %>% 
    arrange(desc(diff)) %>% 
    DT::datatable()
```


### `interp_gen` and `interp_gen_inv`

```{r, message = FALSE}
tau2 <- list()
for (i in seq_along(cpar)){
    eta_ <- cpar[[i]][1]
    alpha_ <- cpar[[i]][2]
    tau2[[i]] <- interp_gen(interp_gen_inv(tau, eta = eta_, alpha = alpha_), eta = eta_, alpha = alpha_)
}
tibble(cpar = cpar) %>% 
    unnest_wider(cpar) %>% 
    rename(eta = ...1, alpha = ...2) %>% 
    mutate(tau_original = list(tau),
           tau_through_inverse = tau2) %>% 
    unnest(everything()) %>% 
    mutate(diff = abs(tau_original - tau_through_inverse)) %>% 
    arrange(desc(diff)) %>% 
    DT::datatable()
```

### `interp_kappa` and `interp_kappa_inv`

```{r, message = FALSE}
tau2 <- list()
for (i in seq_along(cpar)){
    eta_ <- cpar[[i]][1]
    alpha_ <- cpar[[i]][2]
    tau2[[i]] <- interp_kappa(interp_kappa_inv(tau, eta = eta_, alpha = alpha_), eta = eta_, alpha = alpha_)
}
tibble(cpar = cpar) %>% 
    unnest_wider(cpar) %>% 
    rename(eta = ...1, alpha = ...2) %>% 
    mutate(tau_original = list(tau),
           tau_through_inverse = tau2) %>% 
    unnest(everything()) %>% 
    mutate(diff = abs(tau_original - tau_through_inverse)) %>% 
    arrange(desc(diff)) %>% 
    DT::datatable()
```



## `pcondigcop` and `qcongigcop`

```{r, message = FALSE}
tau2 <- list()
for (i in seq_along(cpar)){
    cpar_ <- cpar[[i]]
    tau2[[i]] <- pcondigcop(qcondigcop(tau, u, cpar = cpar_), u, cpar = cpar_)
    test_that("qcondigcop works", {
        expect_equal(tau, tau2[[i]])
    })
}
tibble(cpar = cpar) %>% 
    unnest_wider(cpar) %>% 
    rename(theta = ...1, alpha = ...2) %>% 
    mutate(tau_original = list(tau),
           tau_through_inverse = tau2) %>% 
    unnest(everything()) %>% 
    mutate(diff = abs(tau_original - tau_through_inverse)) %>% 
    arrange(desc(diff)) %>% 
    DT::datatable()
```

## `pcondiglcop` and `qcondiglcop`

```{r, message = FALSE}
tau2 <- list()
for (i in seq_along(cpar)){
    alpha_ <- cpar[[i]][2]
    tau2[[i]] <- pcondiglcop(qcondiglcop(tau, u, cpar = alpha_), u, cpar = alpha_)
    test_that("qcondiglcop works", {
        expect_equal(tau, tau2[[i]])
    })
}
tibble(cpar = cpar) %>% 
    unnest_wider(cpar) %>% 
    rename(theta = ...1, alpha = ...2) %>% 
    mutate(tau_original = list(tau),
           tau_through_inverse = tau2) %>% 
    unnest(everything()) %>% 
    mutate(diff = abs(tau_original - tau_through_inverse)) %>% 
    arrange(desc(diff)) %>% 
    DT::datatable()
```



# Numerical Derivatives

### density from cdf

```{r}
#' Function to calculate numerical derivative
digcop_gaussian_numerical <- function(u, v, cpar, eps = 1.e-5) {
    x <- qnorm(u)
    y <- qnorm(v)
    cdf11 <- pigcop(u, v, cpar) 
    cdf22 <- pigcop(pnorm(x + eps), pnorm(y + eps), cpar)
    cdf21 <- pigcop(pnorm(x + eps), v, cpar)
    cdf12 <- pigcop(u, pnorm(y + eps), cpar)
    (cdf22 + cdf11 - cdf12 - cdf21) / eps ^ 2
}
digcop_gaussian <- function(u, v, cpar) {
    digcop(u, v, cpar) * dnorm(qnorm(u)) * dnorm(qnorm(v))
}
pdf1 <- purrr::map(cpar, digcop_gaussian_numerical, u = u, v = v)
pdf2 <- purrr::map(cpar, digcop_gaussian, u = u, v = v)
tibble(pdf_numeric  = pdf1,
       pdf_original = pdf2,
       u = list(u),
       v = list(v),
       cpar = cpar) %>%
    unnest_wider(cpar, names_sep = "_") %>% 
    unnest(everything()) %>%
    mutate(diff = abs(pdf_numeric - pdf_original)) %>% 
    # ggplot(aes(pdf_original, pdf_numeric)) +
    # geom_point()
    DT::datatable()
test_that("Density is the same as numerical derivitive of cdf", {
    expect_equal(pdf1, pdf2, tolerance = 1e-4)
})
```


### conditional cdf from cdf


```{r}
#' Calculate numerical derivitive
pcondigcop21_numerical <- function(v, u, cpar, eps = 1.e-8) {
    cdf11 <- pigcop(u, v, cpar)
    cdf21 <- pigcop(u + eps, v, cpar)
    (cdf21 - cdf11) / eps
}
pcond1 <- purrr::map(cpar, ~ pcondigcop21_numerical(v, u, .x))
pcond2 <- purrr::map(cpar, ~ pcondigcop21(v, u, .x))
tibble(pcond_numeric = pcond1,
       pcond_original = pcond2,
       cpar = cpar) %>%
    unnest(starts_with("pcond")) %>%
    unnest_wider(cpar, names_sep = "_") %>%
    DT::datatable()
test_that("2|1 is the same as numerical derivitive of cdf", {
    expect_equal(pcond1, pcond2, tolerance = 1e-6)
})
```

### density from conditional cdf

```{r}
#' Calculate numerical derivitive
digcop_numerical_from_2g1 <- function(u, v, cpar, eps = 1.e-7) {
    conda <- pcondigcop21(v, u, cpar)
    condb <- pcondigcop21(v + eps, u, cpar)
    (condb - conda) / eps
}
pdf1 <- purrr::map(cpar, ~ digcop_numerical_from_2g1(u, v, .x))
pdf2 <- purrr::map(cpar, ~ digcop(u, v, .x))
tibble(pcond_numeric = pdf1,
       pcond_original = pdf2,
       cpar = cpar) %>%
    unnest(starts_with("pcond")) %>%
    unnest_wider(cpar, names_sep = "_") %>%
    DT::datatable()
test_that("density is the same as the numerical derivitive of 2|1", {
    expect_equal(pdf1, pdf2, tolerance = 1e-4)
})
```


## SIMULATED DATA

```{r}
set.seed(1)
n <- 1000  # Sample size

dats <- map(cpar, ~ {
    mat <- rigcop(n, cpar = .x)
    colnames(mat) <- c("u", "v")
    as_tibble(mat)
})

#' compute non-parametric cdf
#' - "dat" should be a data frame with names "u" and "v".
#' - "at_u" and "at_v" should be single numerics.
dat_to_cdf <- function(dat, at_u, at_v) {
    dat %>%
        filter(u <= at_u, v <= at_v) %>%
        nrow() / nrow(dat)
}
dat_to_count <- function(dat, at_u, at_v) {
    dat %>%
        filter(u <= at_u, v <= at_v) %>%
        nrow()
}

#cdf_estimate ~ N(cdf, cdf * (1 - cdf) / n )
se <- function(cdf, n) {
    sqrt(cdf * (1 - cdf) / n)
}
eval <- expand_grid(nesting(cpar = cpar, dat = dats),
                    u = 1:9 / 10, v = 1:9 / 10) %>%
    transmute(cdf_simu = pmap_dbl(list(dat, u, v), dat_to_cdf),
              count_simu = pmap_dbl(list(dat, u, v), dat_to_count),
              cdf_true = pmap_dbl(list(u, v, cpar), pigcop),
              se_true = se(cdf_true, n = n),
              norm_score = (cdf_simu - cdf_true) / se_true,
              u_score = pnorm(norm_score),
              u_from_binomial = pbinom(count_simu, size = n, prob = cdf_true))
ggplot(eval, aes(cdf_true, cdf_simu)) +
    geom_point(alpha = 0.2) +
    stat_function(fun = function(x) x + 1.96 * se(x, n = n)) +
    stat_function(fun = function(x) x - 1.96 * se(x, n = n)) +
    labs(x = "actual cdf values",
         y = "nonparametric estimations",
         title = "95% prediction interval from\nnormal-approximated sampling distribution")
ggplot(eval, aes(rank(u_score) / length(u_score), u_score)) +
    geom_point() +
    geom_abline(slope = 1, intercept = 0) +
    labs(x = "actual",
         y = "calculated",
         title = "PP plot of estimates using binomial distribution")
ggplot(eval, aes(norm_score)) +
    geom_histogram(aes(y = ..density..), bins = 20) +
    stat_function(fun = dnorm, colour = "blue") +
    ggtitle("Histogram of normalized estimates.\nShould be N(0, 1).")


#======================================================================

# After fix to IG copula density,
# check with some simulated data.

# If numerical min loglik with nlm is attempted,
# use log(theta) and log(k) as the parameters
# It might be better to implement the negative log-likelihood as a loop
# rather than in vectorized mode.
# Try first on a subset of deseasonailzed data or simulated data.
```

